<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Objects · Schrodinger.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Schrodinger.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="gettingstarted.html">Getting Started</a></li><li class="current"><a class="toctext" href="quantumobjects.html">Quantum Objects</a><ul class="internal"><li><a class="toctext" href="#creating_states-1">Creating States</a></li><li><a class="toctext" href="#Creating-Operators-1">Creating Operators</a></li><li><a class="toctext" href="#Basic-Mathematical-Operations-1">Basic Mathematical Operations</a></li><li><a class="toctext" href="#Other-Quantum-Objects-1">Other Quantum Objects</a></li></ul></li><li><a class="toctext" href="working.html">Working with States and Operators</a></li><li><a class="toctext" href="dynamics.html">Time Evolution and Dynamics</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../api/quobj.html">Quantum Object Types</a></li><li><a class="toctext" href="../api/states.html">State Library</a></li><li><a class="toctext" href="../api/operators.html">Operator Library</a></li><li><a class="toctext" href="../api/functions.html">Function Library</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="quantumobjects.html">Quantum Objects</a></li></ul><a class="edit-page" href="https://github.com/jebej/Schrodinger.jl/tree/e35a777b80c0f7bd0a86da1e0bdae1801ab2893f/docs/src/man/quantumobjects.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Quantum Objects</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Quantum-Objects-1" href="#Quantum-Objects-1">Quantum Objects</a></h1><p>This section is an introduction to the basic objects used in Schrodinger.jl. It contains an overview of the quantum object generation capabilities offered, and basic mathematical operations. There are 4 types of basic quantum objects: <a href="../api/quobj.html#Schrodinger.Ket"><code>Ket</code></a>, <a href="../api/quobj.html#Schrodinger.Bra"><code>Bra</code></a>, <a href="../api/quobj.html#Schrodinger.Density"><code>Density</code></a>, and <a href="../api/quobj.html#Schrodinger.Operator"><code>Operator</code></a>. All of these objects can be created from a Julia vector or matrix, as appropriate, with a generating function, or by composition of previously made objects.</p><p>Since these objects are very similar to regular vectors and matrices, simple mathematics and functions behave as would be expected.</p><p>Functions for creating states and operators are listed in the API sections <a href="../api/states.html#State-Library-1">State Library</a> and <a href="../api/operators.html#Operator-Library-1">Operator Library</a></p><h2><a class="nav-anchor" id="creating_states-1" href="#creating_states-1">Creating States</a></h2><p>There are three ways of representing quantum states: with <code>Ket</code> or <code>Bra</code> vectors for pure states, and with <code>Density</code> matrices for both pure and mixed states.</p><p>We already saw that it is possible to create a pure ket state from a Julia vector using the <a href="../api/quobj.html#Schrodinger.Ket"><code>Ket</code></a> function. Kets (and bras) are by default stored as sparse vectors. Schrodinger.jl exposes a few functions to generate common states. These functions are listed in the table below; click on the function name for more details.</p><table><tr><th>Function</th><th>Type</th><th>Notes</th></tr><tr><td><a href="../api/states.html#Schrodinger.basis-Tuple{Integer,Integer}"><code>basis</code></a></td><td>sparse <code>Ket</code></td><td>A simple basis vector. The function <code>fock</code> is an alias to this one.</td></tr><tr><td><a href="../api/states.html#Schrodinger.coherent-Tuple{Integer,Number}"><code>coherent</code></a></td><td>dense <code>Ket</code></td><td>A quantum harmonic oscillator coherent state.</td></tr><tr><td><a href="../api/states.html#Schrodinger.maxmixed-Tuple{Integer}"><code>maxmixed</code></a></td><td>sparse <code>Density</code></td><td>The maximally mixed state.</td></tr><tr><td><a href="../api/states.html#Schrodinger.thermal-Tuple{Integer,Real}"><code>thermal</code></a></td><td>sparse <code>Density</code></td><td>A thermal state.</td></tr></table><h3><a class="nav-anchor" id="Kets-1" href="#Kets-1">Kets</a></h3><p>A simple computational state like <span>$|3⟩$</span> can be created with the <a href="../api/states.html#Schrodinger.basis-Tuple{Integer,Integer}"><code>basis</code></a> function. <a href="../api/states.html#Schrodinger.basis-Tuple{Integer,Integer}"><code>basis</code></a> takes two arguments: the dimension of the Hilbert space, and the level. Remember that the ground state is given by the zeroth level.</p><p>Let us create a <code>Ket</code> for a three-level atom in the first excited <code>e1</code> state, which is level &quot;1&quot;.</p><pre><code class="language-julia-repl">julia&gt; e1 = basis(3,1)
3-d Schrodinger.Ket{SparseVector{Float64,Int64},1} with space dimensions 3:
1.00∠0°|1⟩</code></pre><p>A quantum harmonic oscillator can be in what is called a <a href="https://en.wikipedia.org/wiki/Coherent_states">coherent state</a>. Schrodinger.jl provides a function to create such a state. A coherent state is parameterized by <span>$α$</span>, which is a complex number determining the amplitude and phase of the state. Remember that a quantum harmonic oscillator is infinite-dimensional. The state space must therefore be truncated to a finite number of level. The <a href="../api/states.html#Schrodinger.coherent-Tuple{Integer,Number}"><code>coherent</code></a> function takes two arguments, the truncated space size <code>N</code>, and <code>α</code>.</p><pre><code class="language-julia-repl">julia&gt; α = 1.5+1im;

julia&gt; Φ = coherent(10,α)
10-d Schrodinger.Ket{Array{Complex{Float64},1},1} with space dimensions 10:
0.47∠101°|3⟩ + 0.45∠67°|2⟩ + 0.42∠135°|4⟩ + 0.35∠34°|1⟩ + 0.34∠168°|5⟩ +...</code></pre><p>A coherent state is a superposition of number states, which is evident when displayed in the number basis. Note the three dots at the end of the line: Schrodinger.jl only displays the 5 largest components of a <code>Ket</code> vector. You can see the full vector with the <a href="man/@ref"><code>full</code></a> function:</p><pre><code class="language-julia-repl">julia&gt; full(Φ)
10-element Array{Complex{Float64},1}:
 0.196912+1.38778e-16im
          0.295368+0.196912im
          0.174045+0.417707im
        -0.0904438+0.462268im
         -0.298846+0.301357im
         -0.335859+0.0686346im
         -0.231869-0.094343im
        -0.0987909-0.145533im
      -0.000832521-0.0994845im
         0.0472052-0.0721079im</code></pre><p>A <em>mixed</em> state is a probabilistic mixture of <em>pure</em> states, and it is important to understand the difference between the two. For example, we can create a superposition between two state of a three-level atom by adding kets together:</p><pre><code class="language-julia-repl">julia&gt; ψ = e1 + basis(3,0)
3-d Schrodinger.Ket{SparseVector{Float64,Int64},1} with space dimensions 3:
1.00∠0°|0⟩ + 1.00∠0°|1⟩</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Notice that the coefficients of the new state <code>ψ</code> add up to 2. By default, Schrodinger.jl does not renormalize states. This is because adding, for example, three states together would incur two renormalization steps (one per addition) and the resulting state would most likely not be what was desired. Instead, you must add up the states you want in the desired proportions, and then use the <a href="man/@ref"><code>normalize!</code></a> function.</p></div></div><p>Let&#39;s make sure that this state is normalized:</p><pre><code class="language-julia-repl">julia&gt; normalize!(ψ)
3-d Schrodinger.Ket{SparseVector{Float64,Int64},1} with space dimensions 3:
0.71∠0°|0⟩ + 0.71∠0°|1⟩</code></pre><p>This pure state now represents a physical quantum superposition.</p><h3><a class="nav-anchor" id="Density-Matrices-1" href="#Density-Matrices-1">Density Matrices</a></h3><p>Let&#39;s now imagine that we have a device that creates three-level atoms, but every time you ask for an one, the machine creates an atom in the state <code>ψ</code> with probability 1/3, and in the state <code>e1</code> with probability 2/3. After pressing the &quot;new atom&quot; button and obtaining a fresh atom, but <em>before</em> looking at it, the state of that atom is unknown. This situation describes a mixed state, and such a state can only be represented by a density matrix.</p><p>In bra-ket notation, the a pure state can be transformed in a density matrix by multiplying it on the right with its dual bra: <span>$|ψ⟩⟨ψ|$</span>. This is done with the complex transpose operation in Schrodinger.jl. This is therefore how we create the correct state for our mystery atom:</p><pre><code class="language-julia-repl">julia&gt; ρ = 1/3 * ψ*ψ&#39; + 2/3 * e1*e1&#39;
3×3 Schrodinger.Density{SparseMatrixCSC{Float64,Int64},1} with space dimensions 3:
 0.166667  0.166667  0.0
 0.166667  0.833333  0.0
 0.0       0.0       0.0</code></pre><p>Notice that because the probabilities 1/2 and 2/3 add up to 1, the density matrix is already properly normalized: its trace is one. If that had not been the case, we could have normalized the density matrix with the <code>normalize!</code> function again.</p><p>Density matrices can also be created directly from a matrix or from a ket with the <a href="../api/quobj.html#Schrodinger.Density"><code>Density</code></a> function:</p><pre><code class="language-julia-repl">julia&gt; ρ += Density(basis(3,2))
3×3 Schrodinger.Density{SparseMatrixCSC{Float64,Int64},1} with space dimensions 3:
 0.166667  0.166667  0.0
 0.166667  0.833333  0.0
 0.0       0.0       1.0

julia&gt; normalize!(ρ)
3×3 Schrodinger.Density{SparseMatrixCSC{Float64,Int64},1} with space dimensions 3:
 0.0833333  0.0833333  0.0
 0.0833333  0.416667   0.0
 0.0        0.0        0.5</code></pre><h2><a class="nav-anchor" id="Creating-Operators-1" href="#Creating-Operators-1">Creating Operators</a></h2><p>Operators are used to act on quantum states, either continuously, through time evolution under a Hamiltonian, or discretely. As mentioned previously, kets are element of a Hilbert space. Operators are not elements of that space, they <em>act</em> on elements to take them to other elements.</p><p>Operators can be created from a Julia matrix with the <a href="../api/quobj.html#Schrodinger.Operator"><code>Operator</code></a> function and are by default stored as sparse matrices. As with states, Schrodinger.jl contains functions to create common operators:</p><table><tr><th>Function</th><th>Type</th><th>Notes</th></tr><tr><td><a href="../api/operators.html#Schrodinger.qzero"><code>qzero</code></a></td><td>sparse <code>Operator</code></td><td>The zero operator.</td></tr><tr><td><a href="../api/operators.html#Schrodinger.qeye"><code>qeye</code></a></td><td>sparse <code>Operator</code></td><td>The identity operator.</td></tr><tr><td><a href="../api/operators.html#Schrodinger.numberop-Tuple{Integer}"><code>numberop</code></a></td><td>sparse <code>Operator</code></td><td>The particle number operator.</td></tr><tr><td><a href="../api/operators.html#Schrodinger.destroy-Tuple{Integer}"><code>destroy</code></a></td><td>sparse <code>Operator</code></td><td>The quantum harmonic oscillator lowering operator.</td></tr><tr><td><a href="../api/operators.html#Schrodinger.create-Tuple{Integer}"><code>create</code></a></td><td>sparse <code>Operator</code></td><td>The quantum harmonic oscillator raising operator.</td></tr><tr><td><a href="../api/operators.html#Schrodinger.displacementop-Tuple{Integer,Number}"><code>displacementop</code></a></td><td>dense <code>Operator</code></td><td>The quantum harmonic oscillator displacement operator.</td></tr><tr><td><a href="../api/operators.html#Schrodinger.squeezeop-Tuple{Integer,Number}"><code>squeezeop</code></a></td><td>dense <code>Operator</code></td><td>The quantum harmonic oscillator squeeze operator.</td></tr></table><p>Schordinger.jl also exposes the 3 Pauli matrices, the identity operator, and the raising and lowering operators for two-level systems (qubits) as built-in constants. Those are <code>σx</code>, <code>σy</code>, <code>σz</code>, <code>σ0</code>, <code>σ₊</code>, and <code>σ₋</code>. Note that unlike QuTiP, the qubit raising operator will raise <span>$|0⟩$</span> to <span>$|1⟩$</span>.</p><p>New operators can be constructed from existing ones by adding them or multiplying them together or with numbers.</p><pre><code class="language-julia-repl">julia&gt; a = destroy(5)
5×5 Schrodinger.Operator{SparseMatrixCSC{Float64,Int64},1} with space dimensions 5:
 0.0  1.0  0.0      0.0      0.0
 0.0  0.0  1.41421  0.0      0.0
 0.0  0.0  0.0      1.73205  0.0
 0.0  0.0  0.0      0.0      2.0
 0.0  0.0  0.0      0.0      0.0

julia&gt; a&#39;*a + 1/2
5×5 Schrodinger.Operator{SparseMatrixCSC{Float64,Int64},1} with space dimensions 5:
 0.5  0.0  0.0  0.0  0.0
 0.0  1.5  0.0  0.0  0.0
 0.0  0.0  2.5  0.0  0.0
 0.0  0.0  0.0  3.5  0.0
 0.0  0.0  0.0  0.0  4.5

julia&gt; a&#39; + a
5×5 Schrodinger.Operator{SparseMatrixCSC{Float64,Int64},1} with space dimensions 5:
 0.0  1.0      0.0      0.0      0.0
 1.0  0.0      1.41421  0.0      0.0
 0.0  1.41421  0.0      1.73205  0.0
 0.0  0.0      1.73205  0.0      2.0
 0.0  0.0      0.0      2.0      0.0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Adding and substracting numbers to and from operators adds (substracts) the identity matrix multiplied by that number.</p></div></div><h2><a class="nav-anchor" id="Basic-Mathematical-Operations-1" href="#Basic-Mathematical-Operations-1">Basic Mathematical Operations</a></h2><p>Basic mathematics with kets, density matrices and operators in Schrodinger.jl is very similar to regular linear algebra with vectors and matrices. This is to be expected, kets are elements of a Hilbert space, which is a vector space, and operators are transformations that take kets to kets. The only difference is that when performing operations between quantum objects, their subspace dimensions must be identical. This condition is explained in more details in the next section.</p><h3><a class="nav-anchor" id="Algebra-1" href="#Algebra-1">Algebra</a></h3><p>All basic algebra functions work as expected:</p><pre><code class="language-julia-repl">julia&gt; basis(2,0) + basis(2,1)
2-d Schrodinger.Ket{SparseVector{Float64,Int64},1} with space dimensions 2:
1.00∠0°|0⟩ + 1.00∠0°|1⟩

julia&gt; basis(3,0) + 1
3-d Schrodinger.Ket{SparseVector{Float64,Int64},1} with space dimensions 3:
2.00∠0°|0⟩ + 1.00∠0°|1⟩ + 1.00∠0°|2⟩

julia&gt; 2.5im*basis(2,0)
2-d Schrodinger.Ket{SparseVector{Complex{Float64},Int64},1} with space dimensions 2:
2.50∠90°|0⟩

julia&gt; thermal(4,0.3)/2 + Density(coherent(4,1))/2
4×4 Schrodinger.Density{Array{Float64,2},1} with space dimensions 4:
 0.569363   0.184874   0.124977   0.0911074
 0.184874   0.275112   0.125807   0.0917127
 0.124977   0.125807   0.105588   0.0619989
 0.0911074  0.0917127  0.0619989  0.049937

julia&gt; numberop(4) + 1/2
4×4 Schrodinger.Operator{SparseMatrixCSC{Float64,Int64},1} with space dimensions 4:
 0.5  0.0  0.0  0.0
 0.0  1.5  0.0  0.0
 0.0  0.0  2.5  0.0
 0.0  0.0  0.0  3.5

julia&gt; create(4)^2
4×4 Schrodinger.Operator{SparseMatrixCSC{Float64,Int64},1} with space dimensions 4:
 0.0      0.0      0.0  0.0
 0.0      0.0      0.0  0.0
 1.41421  0.0      0.0  0.0
 0.0      2.44949  0.0  0.0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>As explained previously, adding and substracting numbers to and from density matrices and operators adds (substracts) the identity matrix multiplied by that number. Adding and substracting quantum objects might also lead to non-normalized states. See the <a href="working.html#Norms-1">Norms</a> section for more details.</p></div></div><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><p>Many other mathematical functions are available and work as expected:</p><ul><li><p><code>exp</code>, <code>sqrt</code>, <code>log</code></p></li><li><p>trig functions are missing for now!</p></li><li><p><code>real</code>, <code>imag</code>, <code>abs</code>, <code>abs2</code></p></li><li><p><code>ctranspose</code>, <code>conj</code>, <code>transpose</code></p></li></ul><h2><a class="nav-anchor" id="Other-Quantum-Objects-1" href="#Other-Quantum-Objects-1">Other Quantum Objects</a></h2><p>There exist other quantum objects, like <a href="man/@ref"><code>Liouvillian</code></a>s and <a href="man/@ref"><code>Propagator</code></a>s, but those will be discussed in later sections.</p><footer><hr/><a class="previous" href="gettingstarted.html"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="working.html"><span class="direction">Next</span><span class="title">Working with States and Operators</span></a></footer></article></body></html>
