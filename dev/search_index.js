var documenterSearchIndex = {"docs":
[{"location":"examples/driven_TLS.html#The-Driven-Two-Level-System","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"","category":"section"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"The driven two-level system (TLS) is one of the very few non-trivial time dependent problem whose dynamics can be solved for analytically. As such it provides a good benchmark for numerical solvers, since we can easily quantify their performance.","category":"page"},{"location":"examples/driven_TLS.html#The-Hamiltonian","page":"The Driven Two-Level System","title":"The Hamiltonian","text":"","category":"section"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"The Hamiltonian of a two-level system is usually expressed with a hatσ_z Pauli operator, but for simplicity, we use a normal number operator, which we multiply by the frequency of the transition between the ground state and the excited state: hatH_0 = hbar ω hatn.","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"The drive consists of an oscillating field in a direction transverse to the TLS. We use a circularly polarized field, meaning that the component of the drive for the g rightarrow w transition is complex and is the complex conjugate of the component of the drive for the w rightarrow g transition. Explicitly, if the drive has strength gamma (in angular frequency units), the drive operator is:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"beginaligned\nhatH_d = hbar gamma beginpmatrix\n0  e^i omega_d t \ne^-i omega_d t  0\nendpmatrix\nendaligned","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"where omega_d is the drive frequency.","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"Note that if the driving field is not circularly polarized, for example if the drive is hbar gamma hatsigma_x cos(omega_d t) (corresponding to linear polarization), the dynamics of the system are no longer solvable analytically.","category":"page"},{"location":"examples/driven_TLS.html#Numerics","page":"The Driven Two-Level System","title":"Numerics","text":"","category":"section"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"Before starting the mathematical derivation, let's let the computer solve the problem for us:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"using Schrodinger, PyPlot\n\n# frequencies, starting state and number operator\nω = 1*2π\nωd = 0.9*2π\nγ = π/2\ng = basis(2,0)\nn = numberop(2)\n\n# drive function, p[1] is the frequency and p[2] is the drive strength\nfd = (t,p) -> p[2]*cis(p[1]*t)\n\n# solve it! we use a drive strength of γ (in angular frequency units)\n# note the negative frequency for circular polarization\nr1 = sesolve((ω*n, (σ₋,fd,[ωd,γ]), (σ₊,fd,[-ωd,γ])), g, (0.0,3.0), saveat=0.01)\n\nfigure(); # hide\nplot(r1.times,levelprobs(r1.states)); grid();\nxlabel(\"Time\"); ylabel(\"Level Probabilities\");\nlegend([\"|g⟩\", \"|e⟩\"]);\ntight_layout(); savefig(joinpath(\"img\",\"driven_TLS_1.svg\")); # hide","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"(Image: driven_TLS_1)","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"Notice that we chose a drive frequency below that of the TLS frequency. This results in a TLS oscillation frequency higher than π (the drive strength), however, the excited state never gets fully occupied.","category":"page"},{"location":"examples/driven_TLS.html#Derivation","page":"The Driven Two-Level System","title":"Derivation","text":"","category":"section"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"We now derive the dynamics of the system analytically, so that we may verify our numerics.","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"First, we move to the interaction picture in order to ignore the precession about the z-axis. We are thus left only with hatH_I = e^i hatH_0 t  hbar hatH_D e^-i hatH_0 t  hbar. For a state with time dependent coefficients c_0 and c_1, the Schrödinger equation thus reads:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"beginaligned\ni hbar dotpsirangle_I = hatH_I psirangle_I \ni hbar beginpmatrix dotc_0  dotc_1 endpmatrix = hbar gamma beginpmatrix 0  e^i Deltaomega t  e^-i Deltaomega t  0 endpmatrix beginpmatrix c_0  c_1 endpmatrix \n = hbar gamma beginpmatrix e^i Deltaomega t c_1  e^-i Deltaomega t c_0 endpmatrix\nendaligned","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"where Deltaomega = omega_d - omega.","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"We thus have a system of coupled differential equations to solve, with initial condition c_0(t=0) = 1 and normalization c_0^2 + c_1^2 = 1. We first decouple the system by isolating c_0(t) in the second equation, differentiating it and inserting the result in the second equation:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"beginaligned\nc_0(t) = igamma  e^i Deltaomega t dotc_1 \ndotc_0(t) = igamma  left( e^i Deltaomega t ddotc_1 + i Deltaomega e^i Deltaomega t dotc_1 right)\nendaligned","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"beginaligned\n-1gamma  left( e^i Deltaomega t ddotc_1 + i Deltaomega e^i Deltaomega t dotc_1 right) = gamma  e^i Deltaomega t c_1 \ne^i Deltaomega t ddotc_1 + i Deltaomega e^i Deltaomega t dotc_1 = -gamma^2  e^i Deltaomega t c_1\nendaligned","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"Finally, since the equation must be valid for all t, we drop the exponential to obtain a homogeneous second order differential equation:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"ddotc_1 + i Deltaomega dotc_1 + gamma^2 c_1 = 0","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"At this point we guess a solution c_1(t) propto e^i alpha t which, when inserted in the differential equation, gives a 2nd order polynomial in alpha:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"beginaligned\n-alpha^2 c_1 + i Deltaomega i alpha c_1 + gamma^2 c_1 = 0 \nalpha^2 + Deltaomega alpha - gamma^2 = 0\nendaligned","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"with solutions","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"beginaligned\nalpha_pm = - Deltaomega2 pm sqrt ( Deltaomega2 )^2 + gamma^2  \n           = - Deltaomega2 pm Omega\nendaligned","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"where we have introduced the well know Rabi frequency Omega = sqrt ( Deltaomega2 )^2 + gamma^2 .","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"As expected, a second order differential equation gives us two solutions, with which we form the general solution:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"c_1(t) = a e^-i Deltaomega t 2 e^i Omega t + b e^-i Deltaomega t 2 e^-i Omega t","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"We can eliminate b by using the initial condition c_1(t=0) = 0, giving us b = -a. This allows us to simplify the general solution:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"c_1(t) = a e^-i Deltaomega t 2 2i sin(Omega t) = c e^-i Deltaomega t 2 sin(Omega t)","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"Finally, to determine the value of a, we insert the general solution back in the original differential equation for c_1(t) and make use of the normalization property:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"beginaligned\ndotc_1 = c ( -i Deltaomega2 e^-i Deltaomega t 2 sin(Omega t) + Omega e^-i Deltaomega t 2 cos(Omega t) ) \n          = gamma e^-i Deltaomega t c_0\nendaligned","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"equating the equations and taking the absolute square:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"beginaligned\ne^-i Deltaomega t 2 c ( -i Deltaomega2 sin(Omega t) + Omega cos(Omega t) ) = gamma e^-i Deltaomega t c_0 \nc^2 ( (Deltaomega2)^2 sin^2(Omega t) + Omega^2 cos^2(Omega t) ) = gamma^2 c_0^2 = gamma^2 ( 1 - c_1^2 ) \nc^2 ( (Deltaomega2)^2 sin^2(Omega t) + Omega^2 cos^2(Omega t) + gamma^2 sin^2(Omega t) )= gamma^2 \nc^2 ( Omega^2 sin^2(Omega t) + Omega^2 cos^2(Omega t) )= gamma^2 \nc^2 Omega^2 = gamma^2 \nc^2 = gamma^2  Omega^2\nendaligned","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"The final solution for c_1(t) then, up to a constant global phase is:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"c_1(t) = gamma  Omega e^-i Deltaomega t 2 sin(Omega t)","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"This equation is quite interesting, and it perfectly explains the non-trivial behavior of the driven TLS. It shows the switching frequency, which is the much celebrated Rabi frequency, and also shows that the maximum transfer probability from the ground to excited state c^2 is a Lorentzian with respect to Deltaomega, the detuning between the drive and the TLS frequency:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"c_1^2_textmax = fracgamma^2gamma^2 + left(fracDeltaomega2right)^2","category":"page"},{"location":"examples/driven_TLS.html#Comparison","page":"The Driven Two-Level System","title":"Comparison","text":"","category":"section"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"In order to compare to the simulation done at the beginning, we simply write a function that computes c_1(t), and plot the outpout against the one from sesolve.","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"c₁(t,γ,Δω) = (Ω = √(γ^2+(Δω/2)^2); γ/Ω * cis(-Δω/2*t) * sin(Ω*t))\n\nΔω = ωd-ω\nc1 = c₁.(r1.times,γ,Δω) # compute data for c₁\nanalytic = [1 .- abs2.(c1) abs2.(c1)] # 1-|c₁|² and |c₁|²\n\nplot(r1.times,analytic)\nlegend([\"|g⟩\", \"|e⟩\", \"|g⟩ (analytic)\", \"|e⟩ (analytic)\"]);\ntight_layout(); savefig(joinpath(\"img\",\"driven_TLS_2.svg\")); # hide","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"(Image: driven_TLS_2)","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"It worked! It is hard to tell that the two lines are on top of each other, but we can numerically compare the data:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"analytic ≈ levelprobs(r1.states)","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"We did omit a detail here: while we calculated c_1(t) in the interaction picture, our simulation was not done in the interaction picture. Instead, we gave the solver the full Hamiltonian. This discrepancy can be seen by comparing the actual amplitude c_1, instead of the probability c_1^2:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"c1 ≈ 1im.*getindex.(r1.states,2) # second index for excited state","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"Note that computationally, it is much more advantageous to perform the simulation in the interaction picture since we avoid simulating the constant precession of the TLS around the z-axis.","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"# in the interaction picture\nr2 = sesolve((qzero(2), (σ₋,fd,[Δω,γ]), (σ₊,fd,[-Δω,γ])), g, (0.0,3.0), saveat=0.01)\n\nc1 ≈ 1im.*getindex.(r2.states,2)","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"Visually, this can be understood by plotting the phase of the state as a function of time:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"figure(); # hide\nplot(r1.times, 180/π.*angle.(1im.*getindex.(r1.states,2)))\nplot(r2.times, 180/π.*angle.(1im.*getindex.(r2.states,2)))\nxlabel(\"Time\"); ylabel(\"∠c₁ (°)\"); grid()\nlegend([\"Schrödinger picture\", \"Interaction picture\"]);\ntight_layout(); savefig(joinpath(\"img\",\"driven_TLS_3.svg\")); # hide","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"(Image: driven_TLS_3)","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"The phase is changing much more rapidly in the Schrödinger picture than in the interaction picture, and thus more points per unit time are required to obtain the same accuracy.","category":"page"},{"location":"examples/driven_TLS.html#Chevron-Pattern","page":"The Driven Two-Level System","title":"Chevron Pattern","text":"","category":"section"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"A cool experiment that can be done with qubits is to verify that the TLS dynamics hold over a range of driving frequencies. We drive a qubit at various frequencies and measure the excited state probability over time. This leads to a very nice \"chevron pattern\" plot:","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"figure(); # hide\nt = 0:0.1:12\nωd_ratio = transpose(0.5:0.01:1.5)\nchev = abs2.(c₁.(t,γ,ω.*ωd_ratio.-ω))\nimshow(chev,origin=\"lower\",extent=[0.5,1.5,0,12],aspect=1/15)\nxlabel(\"\\$ω_d/ω\\$\"); ylabel(\"Time\");\ntight_layout(); savefig(joinpath(\"img\",\"driven_TLS_4.svg\")); # hide","category":"page"},{"location":"examples/driven_TLS.html","page":"The Driven Two-Level System","title":"The Driven Two-Level System","text":"(Image: driven_TLS_4)","category":"page"},{"location":"man/gettingstarted.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/gettingstarted.html#First-Steps","page":"Getting Started","title":"First Steps","text":"","category":"section"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"The first step to using Schrodinger.jl is to install it. This is easy to do with Julia's package manager. Type using Pkg; Pkg.add(url=\"https://github.com/jebej/Schrodinger.jl.git\") at the Julia REPL to download the package to your computer. From there, the package can be used or imported like any other Julia package:","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"using Schrodinger","category":"page"},{"location":"man/gettingstarted.html#Quantum-States","page":"Getting Started","title":"Quantum States","text":"","category":"section"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"In quantum mechanics, one of the most fundamental object for describing the state of a system is a state vector. State vectors represent pure quantum states, as opposed to mixed quantum stated, but we will get to that later.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"Schrodinger.jl uses the ubiquitous \"bra-ket\" formalism to describe pure states. A ket is nothing more than a normal (column) vector, which in linear algebra lingo are elements of a vector space. In quantum mechanics, the vector space within which ket vectors live is called a Hilbert space.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"Kets (and their dual, bras) are therefore finite-, or infinite-dimensional vectors. To create a ket in Schrodinger.jl, use the Ket function with a vector as an argument:","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"julia> g = Ket([1,0])\n2-d Ket{Vector{Float64}, 1} with dimensions 2\n1.00∠0°|0⟩","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"The output is a bit busy, so let us go through it.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"The input to the Ket function was a 2-d vector [1,0]. This can be seen of the first line of the output, which starts with \"2-d\". The next term is the type of the object, which is a Schrodinger (the package name) Ket (the type itself). The Ket type is parameterized by two values, which are seen within the curly brackets and separated by a comma: first, the type of the underlying data, which here is a 1-d Array of Float64 values (by default, kets and other objects are stored in the format you give to the constructor, although the elements will be converted to floating point values), and second, the total number of subspaces in the full Hilbert space that the Ket lives in. Here, the number is simply 1. The end of the line states the subspace dimensions, but since we have only 1 subspace with dimension 2, this is not very interesting.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"The second line prints the vector in bra-ket polar notation. Since the vector we passed had the entry \"1\" in the \"zeroth\" (which is the first) dimension, the ket we get is simply 0.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"Schrodinger.jl only supports finite dimensional Hilbert spaces. If the physical system you want to describe is infinite-dimensional, it will need to be truncated.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"note: Note\nAll objects in Schrodinger.jl are expressed in the computational or number basis. This means that the ground state is 0, and exited states are numbered starting from 1: 1 2 3","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"To learn more about quantum states in Schrodinger.jl, including mixed states represented by density matrices, please see the next section.","category":"page"},{"location":"man/gettingstarted.html#Operators","page":"Getting Started","title":"Operators","text":"","category":"section"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"States are useful, but we need to do something with them. This is what an Operator is for. Note that Operators have the same Julia type as density matrices (the Operator type), but they can be non-Hermitian, and are in general not normalized.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"Operators act on elements of a Hilbert space (that is, on kets) to modify them. An operator is thus a like a function that takes as input a ket, and returns a new one. The natural representation for an operator is a matrix, but in Schrodinger.jl you need to use the Operator type, which stores a matrix and other important information about the operator.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"Arbitrary operators can of course be created, but let's take a look at one that is built-in, the σ_x operator:","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"julia> σx\n2×2 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 2\n  ⋅   1.0\n 1.0   ⋅","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"Notice that the first line of the output is very similar to that of the ket we created above. It lists the dimensions of the matrix, the type (which lists the type of the underlying matrix and the number of subspaces), and the space dimensions (which again is just a single 2-d space).","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"The state g that we created in the previous section is a ground state with the same dimensions. Thus, the σ_x operator can act on it! This is done simply by multiplying the two objects, with the operator acting to the right on the ket:","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"julia> σx*g\n2-d Ket{Vector{Float64}, 1} with dimensions 2\n1.00∠0°|1⟩","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"As expected, the output is a Ket, but notice the state is now 1! By acting on the ground state 0 with the σ_x operator, we obtained the excited state. This is because the σ_x operator is the \"flip\" operator. It takes 0 to 1, and 1 to 0. If we apply σ_x twice then, we get 0 back:","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"julia> σx*σx*g\n2-d Ket{Vector{Float64}, 1} with dimensions 2\n1.00∠0°|0⟩","category":"page"},{"location":"man/gettingstarted.html#Simple-Dynamics","page":"Getting Started","title":"Simple Dynamics","text":"","category":"section"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"Now that we have a state and an operator, we can perform some time dynamics! The σ_x operator, in the context of a spin-1/2 system, can represent a transverse magnetic field. In such a situation, a particle starting in the ground state will undergo sinusoidal oscillations between 0 and 1 due to the action of the field. Let's simulate it!","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"We first set up the Hamiltonian, assuming our field has an angular frequency ω=102π (i.e. 1 Hz). If we look at a 2 sec timespan, we should thus see 2 full periods. To measure the value of the spin at each instant in time, we choose the -σ_z operator as our observable. The minus sign ensures that the 0 state is the lowest energy one (again, because we are in the computational basis).","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"ω = 1.0*2π # angular frequency\nH = ω/2*σx # Hamiltonian\nt = (0.0,2.0) # timespan\nO = -σz # observable\n# output\n2×2 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 2\n -1.0   ⋅\n   ⋅   1.0","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"note: Note\nSchrodinger.jl uses units where ħ is equal to 1. Make sure that your Hamiltonian is expressed in units of angular frequency, not energy. If you do have a Hamiltonian expressed in energy units, just use the scale! function: scale!(H,1/ħ). The variable ħ is exported by the module and so can be used as-is.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"We can now pass all three arguments (H, g and O) to the sesolve function (Schrodinger Equation solver) to solve for the time dynamics! We also pass a keyword argument saveat to make sure we have enough points. As can be seen, the results match with theory:","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"res = sesolve(H, g, t, O, saveat=2/200)\nreal.(res.evals) ≈ -cos.(ω.*res.times) # check against theory\n# output\ntrue","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"Let's plot the results!","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"using PyPlot\nplot(res.times,real.(res.evals)); xlabel(\"time (s)\"); legend([\"\\$⟨-σ_z⟩\\$\"]); grid()","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"(Image: spin-1/2 system oscillations)","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"As we predicted, the system oscillates between -1, the expectation value of -σ_z when in the ground state, and 1 when in the excited state.","category":"page"},{"location":"man/gettingstarted.html","page":"Getting Started","title":"Getting Started","text":"This concludes the first section of the manual. Hopefully you now know enough to get started with simple quantum operations. If you would like to learn more about the other features of Schrodinger.jl, keep reading!","category":"page"},{"location":"api/quobj.html#Quantum-Object-Types","page":"Quantum Object Types","title":"Quantum Object Types","text":"","category":"section"},{"location":"api/quobj.html#Schrodinger.Bra","page":"Quantum Object Types","title":"Schrodinger.Bra","text":"Bra(x, dims=(length(x),))\n\nBra vector type. The dual vector to the Ket.\n\nThe Bra type has two fields, data and dims, which store the vector data and the subspace dimensions. A Bra, like a Ket or an Operator is parameterized by the number of subspaces it lives in. Two different kets must have the same system dimensions in order to be added together.\n\nIt is possible to normalize the bra vector after construction with the normalize! function.\n\n\n\n\n\n","category":"type"},{"location":"api/quobj.html#Schrodinger.Ket","page":"Quantum Object Types","title":"Schrodinger.Ket","text":"Ket(x, dims=(length(x),))\n\nConstruct a ket state vector from the vector x. A vector of length N will by default be assumed to be an element of a single Hilbert space of dimension N. If the vector is an element of a tensor product of Hilbert spaces, the dimensions can be defined manually by passing a tuple of subspace dimensions dims. In that case, prod(dims) must equal length(x). By default, the vector is stored in sparse format.\n\nThe Ket type has two fields, data and dims, which store the vector data and the subspace dimensions. A Ket, like a Bra or an Operator is parameterized by the number of subspaces it lives in. Two different kets must have the same system dimensions in order to be added together.\n\nIt is possible to normalize the ket vector after construction with the normalize! function.\n\nExample\n\njulia> ψ = normalize!(Ket([1,1]))\n2-d Ket{Vector{Float64}, 1} with dimensions 2\n0.71∠0°|0⟩ + 0.71∠0°|1⟩\n\n\n\n\n\n","category":"type"},{"location":"api/quobj.html#Schrodinger.Operator","page":"Quantum Object Types","title":"Schrodinger.Operator","text":"Operator(B, dims=(size(B,1),))\n\nConstruct a linear operator from the matrix B. An N×N matrix will by default be assumed to describe an operator that acts on a single Hilbert space of dimension N. If the matrix represents a linear operator on a tensor product of Hilbert spaces, the dimensions can be defined manually by passing a tuple of subspace dimensions dims. In that case, prod(dims) must equal size(B,1).\n\nThe Operator type has two fields, data and dims, which store the matrix data and the subspace dimensions. An Operator, like a Ket or a Bra, is parameterized by the number of subspaces it lives in. Two different density matrices must have the same system dimensions in order to be added together. An Operator may or may not be Hermitian.\n\nExample\n\njulia> σ = Operator([0 -im ; im 0])\n2×2 Operator{Matrix{ComplexF64}, 1} with dimensions 2\n 0.0+0.0im  0.0-1.0im\n 0.0+1.0im  0.0+0.0im\n\n\n\n\n\n","category":"type"},{"location":"api/quobj.html#Schrodinger.data-Tuple{Schrodinger.QuObject}","page":"Quantum Object Types","title":"Schrodinger.data","text":"data(A::QuObject)\n\nExtract the object storing the data; for example, a Vector or a SparseMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/functions.html#Function-Library","page":"Function Library","title":"Function Library","text":"","category":"section"},{"location":"api/functions.html#Schrodinger.entanglement_fidelity","page":"Function Library","title":"Schrodinger.entanglement_fidelity","text":"entanglement_fidelity(U,V)\n\nCompute the entanglement fidelity of an imperfect quantum operation V with respect to an ideal operation U. The entanglement fidelity is given by the following formula:\n\nF_texte(mathcalE) = ϕ(ImathcalE)(ϕ)ϕ\n\nwhere ϕ = frac1sqrtd_i=1^dii is the maximally entangled state and mathcalE is a trace preserving quantum operation.\n\nWhen trying to find the fidelity of a quantum gate U, implemented imperfectly as V, then mathcalE = U^V. In the case where U and V are a simple operators,\n\n(ImathcalE)(ϕ) = (IU^V)ϕϕ(IU^V)^ quadtextand so\n\nbeginaligned\nF_texte(mathcalE) = ϕ(IU^V)ϕϕ(IU^V)^ϕ \n  = ϕ(IU^V)ϕ^2 \n  = UV^2d^2 \nendaligned\n\nThe entanglement fidelity is related to the average gate fidelity by\n\noverlineF(mathcalE) =  fracd F_texte(mathcalE) + 1d + 1\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#Schrodinger.expect-Tuple{Operator, Ket}","page":"Function Library","title":"Schrodinger.expect","text":"expect(σ,ψ), expect(σ,ρ)\n\nCompute the expectation value of an operator σ given a state ket ψ or a density matrix ρ. The expectation value is defined as\n\nbeginaligned\nE(σψ) = ψσψ \nE(σρ) = texttr(σρ)\nendaligned\n\nA specialized method exists for vector of Ket or Operator inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/functions.html#Schrodinger.fidelity-Tuple{Operator, Operator}","page":"Function Library","title":"Schrodinger.fidelity","text":"fidelity(ρ,σ), fidelity(ρ,ψ), fidelity(ψ,ϕ)\n\nCompute the fidelity between density matrices ρ and σ, a density matrix ρ and a ket ψ, or two kets ψ and ϕ. The fidelity in those three cases is defined as\n\nbeginaligned\nF(ρσ) = texttrsqrtρ^12σρ^12 \nF(ρψ) = sqrtψρψ \nF(ψϕ) = leftψϕright\nendaligned\n\nSee also fidelity2, which is the square of the state fidelity.\n\n\n\n\n\n","category":"method"},{"location":"api/functions.html#Schrodinger.fidelity2-Tuple{Operator, Operator}","page":"Function Library","title":"Schrodinger.fidelity2","text":"fidelity2(ρ,ψ)\n\nCompute the Uhlmann state fidelity between density matrices ρ and σ, a density matrix ρ and a ket ψ, or two kets ψ and ϕ. The Uhlmann state fidelity is simply defined as the square of the \"regular\" state fidelity.\n\n\n\n\n\n","category":"method"},{"location":"api/functions.html#Schrodinger.gate_fidelity","page":"Function Library","title":"Schrodinger.gate_fidelity","text":"gate_fidelity(U,V)\n\nCompute the average gate fidelity of an imperfect quantum operation V with respect to an ideal operation U.\n\nThe average gate fidelity is related to the entanglement fidelity by\n\noverlineF(mathcalE) =  fracd F_texte(mathcalE) + 1d + 1\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#Schrodinger.levelprobs-Union{Tuple{Ket{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Function Library","title":"Schrodinger.levelprobs","text":"levelprobs(ψ), levelprobs(ψ,s)\n\nCompute the level occupation probabilities. For a Ket, this simply corresponds to the absolute square of the amplitude of each level. For an Operator, the function returns the diagonal.\n\nA system index, or vector of indices, can be passed as a second argument. In that case, the full system will first be partial traced to keep only the desired index. Level occupation probabilities are then calculated from the resulting reduced density matrix. If a vector of indices is passed, occupation probabilities are calculated for a fully reduced density matrix for each index.\n\nSpecialized methods exists for vectors of Ket or Operator inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/functions.html#Schrodinger.purity-Tuple{Operator}","page":"Function Library","title":"Schrodinger.purity","text":"purity(ρ)\n\nCompute the purity of a quantum state ρ, defined by\n\nγ = texttr(ρ^ρ)\n\nThis is the same as the square of the Frobenius norm of a matrix.\n\nThe purity of a quantum state is bounded below by 1/d, for a maximally mixed state, and above by 1, for a pure state. Note that the purity of a Ket is 1 by definition.\n\nThe purity is related to the linear entropy S_L by S_L = 1-γ.\n\n\n\n\n\n","category":"method"},{"location":"api/functions.html#Schrodinger.ptrace-Tuple{Ket, Any}","page":"Function Library","title":"Schrodinger.ptrace","text":"ptrace(ψ, out)\n\nCompute the partial trace of a state Ket or Bra ψ by tracing out the subsystems specified by out. Returns a density matrix. Multiple subsystems can be traced out by passing a sorted tuple of subsystem indices.\n\nExample\n\njulia> Φ₊ = normalize!(basis(2,0)⊗basis(2,0) + basis(2,1)⊗basis(2,1)) # Bell pair\n4-d Ket{SparseVector{Float64, Int64}, 2} with dimensions 2⊗2\n0.71∠0°|0,0⟩ + 0.71∠0°|1,1⟩\n\njulia> ptrace(Φ₊,1) # trace out qubit 1\n2×2 Operator{Matrix{Float64}, 1} with dimensions 2\n 0.5  0.0\n 0.0  0.5\n\n\n\n\n\n","category":"method"},{"location":"api/functions.html#Schrodinger.ptrace-Tuple{Operator, Any}","page":"Function Library","title":"Schrodinger.ptrace","text":"ptrace(ρ, out)\n\nCompute the partial trace of a linear Operator ρ by tracing out the subsystems specified by out. Multiple subsystems can be traced out by passing a sorted tuple of subsystem indices.\n\nExample\n\nΦ₊ = normalize!(basis(2,0)⊗basis(2,0) + basis(2,1)⊗basis(2,1)) # Bell pair\nΨ₊ = normalize!(basis(2,0)⊗basis(2,1) + basis(2,1)⊗basis(2,0)) # Bell pair\nρ  = 0.25 * Operator(Φ₊) + 0.75 * Operator(Ψ₊) # density matrix\nptrace(ρ,2) # trace out qubit 2\n# output\n2×2 Operator{Matrix{Float64}, 1} with dimensions 2\n 0.5  0.0\n 0.0  0.5\n\n\n\n\n\n","category":"method"},{"location":"api/functions.html#Schrodinger.operator_to_choi-Tuple{Operator}","page":"Function Library","title":"Schrodinger.operator_to_choi","text":"operator_to_choi(O)\n\nCompute the Choi matrix C_O of a unitary map represented by an operator O. We use the convention of applying O to the second half of the extended Hilbert space, i.e.:\n\nC_O = _ij ij  OijO^\n\n\n\n\n\n","category":"method"},{"location":"man/index.html#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"man/index.html","page":"Manual","title":"Manual","text":"The manual is divided by topics. Reading the Getting Started is recommended. It briefly goes through the fundamental aspect of the package. Users interested in more in-depth explanations can then explore the following sections.","category":"page"},{"location":"man/index.html","page":"Manual","title":"Manual","text":"Pages = [\"gettingstarted.md\"]","category":"page"},{"location":"man/working.html#Working-with-States-and-Operators","page":"Working with States and Operators","title":"Working with States and Operators","text":"","category":"section"},{"location":"man/working.html","page":"Working with States and Operators","title":"Working with States and Operators","text":"Now that we know how to create states and operators, we would like to know what we can do with them. This section describes the fundamental quantum mechanical operations that can be performed in Schrodinger.jl.","category":"page"},{"location":"man/working.html#Acting-on-States-with-Operators","page":"Working with States and Operators","title":"Acting on States with Operators","text":"","category":"section"},{"location":"man/working.html","page":"Working with States and Operators","title":"Working with States and Operators","text":"Multiplying operators and states\nApplying the raising and lowering operator, especially show the lowering operator on the zero state","category":"page"},{"location":"man/working.html","page":"Working with States and Operators","title":"Working with States and Operators","text":"Operators cannot act directly on density matrices, because operators and density matrices both are linear operators. Instead, we can create a superoperator. These are just operators that act on operators. Mathematically, since density matrices are themselves elements of a vector space (not the same one as for kets, however), we can perform linear operations on them. This is what superoperators do.","category":"page"},{"location":"man/working.html#Norms","page":"Working with States and Operators","title":"Norms","text":"","category":"section"},{"location":"man/working.html","page":"Working with States and Operators","title":"Working with States and Operators","text":"Calculating the norm/trace\nNormalization and renormalization","category":"page"},{"location":"man/working.html#Tensor-Products","page":"Working with States and Operators","title":"Tensor Products","text":"","category":"section"},{"location":"man/working.html#The-Partial-Trace","page":"Working with States and Operators","title":"The Partial Trace","text":"","category":"section"},{"location":"man/working.html#Expectation-Values","page":"Working with States and Operators","title":"Expectation Values","text":"","category":"section"},{"location":"man/working.html","page":"Working with States and Operators","title":"Working with States and Operators","text":"One of the most fundamental operation in quantum mechanics is the measurement of a physical Hermitian operator, like particle number, or of a non-Hermitian operator. Both operations, though they have different physical implications (physical observables must be Hermitian) are done in the same way: by calculating the expectation value of the operator with respect to a particular state.","category":"page"},{"location":"man/working.html","page":"Working with States and Operators","title":"Working with States and Operators","text":"Calculating expectation values is done with the expect function, both with kets and density matrices, although the familiar mathematical notation can be used as well.","category":"page"},{"location":"man/working.html","page":"Working with States and Operators","title":"Working with States and Operators","text":"Let's start with a qubit as a simple example.","category":"page"},{"location":"man/dynamics.html#Time-Evolution-and-Dynamics","page":"Time Evolution and Dynamics","title":"Time Evolution and Dynamics","text":"","category":"section"},{"location":"api/states.html#State-Library","page":"State Library","title":"State Library","text":"","category":"section"},{"location":"api/states.html#Schrodinger.@qb_str-Tuple{AbstractString}","page":"State Library","title":"Schrodinger.@qb_str","text":"qb\"bitstring\"\n\nGenerate a qubit state ket from the given bitstring. This string macro can also be invoked via the macro notation @qb_str \"bitstring\".\n\nReturns a sparse vector.\n\nExample\n\njulia> Ψ⁻ = normalize!(qb\"01\" - qb\"10\")\n4-d Ket{SparseVector{Float64, Int64}, 2} with dimensions 2⊗2\n0.71∠0°|0,1⟩ + 0.71∠180°|1,0⟩\n\nSee also: ket, for generating arbitrary states.\n\n\n\n\n\n","category":"macro"},{"location":"api/states.html#Schrodinger.basis-Tuple{Integer, Tuple{Vararg{Int64, N}} where N}","page":"State Library","title":"Schrodinger.basis","text":"basis(N, n)\n\nGenerate a basis state (a.k.a. Fock or number state) ket n, in a Hilbert space of size N. Note that the size of the Hilbert space must be at least n+1. The function fock is an alias for basis.\n\nReturns a sparse vector.\n\nExample\n\njulia> ψ = basis(3,2)\n3-d Ket{SparseVector{Float64, Int64}, 1} with dimensions 3\n1.00∠0°|2⟩\n\n\n\n\n\n","category":"method"},{"location":"api/states.html#Schrodinger.coherent","page":"State Library","title":"Schrodinger.coherent","text":"coherent(N, α, analytic=false)\n\nGenerate a coherent state ket α, in a Hilbert space of size N. To create a coherent density operator, use the Operator function: Operator(coherent(N,n)).\n\nTwo methods can be used for generating a coherent state: via application of a displacment operator on a ground state (the default), or analytically, with the formula\n\nα = e^-fracα^22 _n=0^N-1 fracα^nsqrtn n\n\nWhile the operator method will return a normalized ket, the analytic method will not. Both methods converge as N gets larger. The analytic method is also much faster, especially for large N.\n\nReturns a dense vector.\n\nExample\n\njulia> coherent(6,0.4+1im)\n6-d Ket{Vector{ComplexF64}, 1} with dimensions 6\n0.60∠68°|1⟩ + 0.56∠0°|0⟩ + 0.46∠136°|2⟩ + 0.29∠-155°|3⟩ + 0.15∠-87°|4⟩ +…\n\n\n\n\n\n","category":"function"},{"location":"api/states.html#Schrodinger.ket-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Int64}} where N","page":"State Library","title":"Schrodinger.ket","text":"ket(state,dims=2)\n\nGenerate a state ket from a tuple of basis levels and a tuple of corresponding space dimensions. Note that each space dimension must be larger than the level by at least 1. If only an integer is passed to dims, all basis levels will have the same dimension.\n\nReturns a sparse vector.\n\nExample\n\njulia> ψ = ket((3,0,1),(5,2,3))\n30-d Ket{SparseVector{Float64, Int64}, 3} with dimensions 5⊗2⊗3\n1.00∠0°|3,0,1⟩\n\nSee also: @qb_str, for generating qubit states via a bitstring.\n\n\n\n\n\n","category":"method"},{"location":"api/states.html#Schrodinger.maxentangled","page":"State Library","title":"Schrodinger.maxentangled","text":"maxentangled(n,N=2)\n\nGenerate a maximally entangled state between n N-d systems:\n\nϕ=_j=0^N-1frac1sqrtNj^n\n\nTracing out all but one of the entangled systems results in a maximally mixed state.\n\nExample\n\njulia> ψ = maxentangled(3,4)\n64-d Ket{SparseVector{Float64, Int64}, 3} with dimensions 4⊗4⊗4\n0.50∠0°|0,0,0⟩ + 0.50∠0°|1,1,1⟩ + 0.50∠0°|2,2,2⟩ + 0.50∠0°|3,3,3⟩\n\njulia> ptrace(ψ,(1,3))\n4×4 Operator{Matrix{Float64}, 1} with dimensions 4\n 0.25  0.0   0.0   0.0\n 0.0   0.25  0.0   0.0\n 0.0   0.0   0.25  0.0\n 0.0   0.0   0.0   0.25\n\n\n\n\n\n","category":"function"},{"location":"api/states.html#Schrodinger.maxmixed-Tuple{Integer}","page":"State Library","title":"Schrodinger.maxmixed","text":"maxmixed(N)\n\nGenerate a maximally mixed density matrix. The maximally mixed state is a mixture of basis states with uniform probability.\n\nReturns a sparse matrix.\n\nExample\n\njulia> maxmixed(4)\n4×4 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 4\n 0.25   ⋅     ⋅     ⋅\n  ⋅    0.25   ⋅     ⋅\n  ⋅     ⋅    0.25   ⋅\n  ⋅     ⋅     ⋅    0.25\n\n\n\n\n\n","category":"method"},{"location":"api/states.html#Schrodinger.thermal-Tuple{Integer, Real}","page":"State Library","title":"Schrodinger.thermal","text":"thermal(N, n)\n\nGenerate a thermal state density matrix ρ_n with particle number n, in a Hilbert space of size N. A thermal state ρ_n is a probabilistic mixture of basis states such that the expectation value of the number operator hatn is n. Note that this is true only if Nn. The returned density matrix is always normalized.\n\nReturns a sparse matrix.\n\nExample\n\njulia> N=5; n=0.2;\n\njulia> ρ = thermal(N,n)\n5×5 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 5\n 0.833441   ⋅         ⋅          ⋅           ⋅\n  ⋅        0.138907   ⋅          ⋅           ⋅\n  ⋅         ⋅        0.0231511   ⋅           ⋅\n  ⋅         ⋅         ⋅         0.00385852   ⋅\n  ⋅         ⋅         ⋅          ⋅          0.000643087\n\njulia> expect(numberop(N),ρ)\n0.19935691318327978\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Operator-Library","page":"Operator Library","title":"Operator Library","text":"","category":"section"},{"location":"api/operators.html#Schrodinger.Sigma1-Tuple{Any}","page":"Operator Library","title":"Schrodinger.Sigma1","text":"Sigma1(N)\n\nGenerate the N-d shift matrix Σ₁.\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.Sigma3-Tuple{Any}","page":"Operator Library","title":"Schrodinger.Sigma3","text":"Sigma3(N)\n\nGenerate the N-d clock matrix Σ₃.\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.create-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:Number","page":"Operator Library","title":"Schrodinger.create","text":"create(N)\n\nGenerate a quantum harmonic oscillator raising (creation) operator hata^ in a truncated Hilbert space of size N. Returns a sparse matrix.\n\nExample\n\njulia> create(4)\n4×4 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 4\n  ⋅    ⋅        ⋅        ⋅\n 1.0   ⋅        ⋅        ⋅\n  ⋅   1.41421   ⋅        ⋅\n  ⋅    ⋅       1.73205   ⋅\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.destroy-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:Number","page":"Operator Library","title":"Schrodinger.destroy","text":"destroy(N)\n\nGenerate a quantum harmonic oscillator lowering (annihilation) operator hata in a truncated Hilbert space of size N. Returns a sparse matrix.\n\nExample\n\njulia> destroy(4)\n4×4 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 4\n  ⋅   1.0   ⋅        ⋅\n  ⋅    ⋅   1.41421   ⋅\n  ⋅    ⋅    ⋅       1.73205\n  ⋅    ⋅    ⋅        ⋅\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.displacementop-Tuple{Integer, Number}","page":"Operator Library","title":"Schrodinger.displacementop","text":"displacementop(N, α)\n\nGenerate a quantum harmonic oscillator displacement operator hatD(α) in a truncated Hilbert space of size N. Returns a dense matrix.\n\nhatD(α) = expleft(αhata^ - α^*hataright)\n\nExample\n\njulia> displacementop(3,0.5im)\n3×3 Operator{Matrix{ComplexF64}, 1} with dimensions 3\n   0.88262+0.0im            0.0+0.439802im  -0.166001+0.0im\n       0.0+0.439802im  0.647859+0.0im             0.0+0.621974im\n -0.166001+0.0im            0.0+0.621974im    0.76524+0.0im\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.numberop-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:Number","page":"Operator Library","title":"Schrodinger.numberop","text":"numberop(N)\n\nGenerate a number operator hatn in a Hilbert space of size N. Returns a sparse matrix.\n\nExample\n\njulia> numberop(4)\n4×4 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 4\n 0.0   ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅\n  ⋅    ⋅   2.0   ⋅\n  ⋅    ⋅    ⋅   3.0\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.projectorop-Tuple{Integer, AbstractVector{var\"#s59\"} where var\"#s59\"<:Integer}","page":"Operator Library","title":"Schrodinger.projectorop","text":"projectorop(N,S)\n\nGenerate a projector on the subspaces defined by an integer or a vector/range of integers S:\n\nP = _iS ii\n\nExample\n\njulia> projectorop(5,[1,3])\n5×5 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 5\n  ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅   1.0   ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.qeye-Union{Tuple{T}, Tuple{Type{T}, Integer}, Tuple{Type{T}, Integer, Tuple{Vararg{Int64, N}} where N}} where T<:Number","page":"Operator Library","title":"Schrodinger.qeye","text":"qeye(N, dims=(N,))\n\nGenerate an identity operator for a Hilbert space of size N. It is possible to specify the subspace dimensions with the dims argument. Returns a sparse matrix.\n\nExample\n\njulia> qeye(4,(2,2))\n4×4 Operator{SparseMatrixCSC{Float64, Int64}, 2} with dimensions 2⊗2\n 1.0   ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅\n  ⋅    ⋅   1.0   ⋅\n  ⋅    ⋅    ⋅   1.0\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.qzero-Union{Tuple{T}, Tuple{Type{T}, Integer}, Tuple{Type{T}, Integer, Tuple{Vararg{Int64, N}} where N}} where T<:Number","page":"Operator Library","title":"Schrodinger.qzero","text":"qzero(N, dims=(N,))\n\nGenerate a zero operator for a Hilbert space of size N. It is possible to specify the subspace dimensions with the dims argument. Returns a sparse matrix.\n\nExample\n\njulia> qzero(4,(2,2))\n4×4 Operator{SparseMatrixCSC{Float64, Int64}, 2} with dimensions 2⊗2\n  ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.squeezeop-Tuple{Integer, Number}","page":"Operator Library","title":"Schrodinger.squeezeop","text":"squeezeop(N, z)\n\nGenerate a quantum harmonic oscillator squeeze operator hatS(z) in a truncated Hilbert space of size N. Returns a dense matrix.\n\nhatS(z) = expleft(frac12left(z^*hata^2 - zhata^2right)right)\n\nExample\n\njulia> squeezeop(3,0.5im)\n3×3 Operator{Matrix{ComplexF64}, 1} with dimensions 3\n 0.938148-0.0im       0.0-0.0im       0.0-0.346234im\n      0.0+0.0im       1.0+0.0im       0.0+0.0im\n      0.0-0.346234im  0.0-0.0im  0.938148-0.0im\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.sylvesterop-Tuple{Integer, Integer, Integer}","page":"Operator Library","title":"Schrodinger.sylvesterop","text":"sylvesterop(N,k,l)\n\nGenerate the (kj)^textth Sylvester generalized Pauli matrix in N-d. https://en.wikipedia.org/wiki/GeneralizationsofPauli_matrices\n\n\n\n\n\n","category":"method"},{"location":"api/operators.html#Schrodinger.rand_unitary","page":"Operator Library","title":"Schrodinger.rand_unitary","text":"rand_unitary(N, dims=(N,))\n\nGenerate a Haar distributed random unitary operator for a Hilbert space of size N. It is possible to specify the subspace dimensions with the dims argument. Returns a dense matrix.\n\nExample\n\njulia> U = rand_unitary(4,(2,2));\n\njulia> U'*U ≈ qeye(4,(2,2))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/operators.html#Schrodinger.Gate.rotation","page":"Operator Library","title":"Schrodinger.Gate.rotation","text":"Gate.rotation(θ, n=(1,0,0))\n\nGenerate a qubit rotation operator giving a θ rad rotation about an axis defined by the vector vecn. Note that n will be normalized, allowing for inputs like (1,1,0). The rotation operator is defined as\n\nhatR_vecn(θ) = expleft(iθvecnvecσ2right) = cosfracθ2𝕀 - isinfracθ2(n_x σ_x + n_y σ_y + n_z σ_z)\n\n\n\n\n\n","category":"function"},{"location":"api/operators.html#Schrodinger.Gate.H","page":"Operator Library","title":"Schrodinger.Gate.H","text":"Gate.H\n\nThe Hadamard gate:\n\nH = frac1sqrt 2\nbeginpmatrix\n1  1 \n1  -1\nendpmatrix\n\nThe Hadamard is a π rotation about the axis vecn = (101), plus a global i phase.\n\n\n\n\n\n","category":"constant"},{"location":"api/operators.html#Schrodinger.Gate.S","page":"Operator Library","title":"Schrodinger.Gate.S","text":"Gate.S\n\nThe phase gate:\n\nS =\nbeginpmatrix\n1  0 \n0  i\nendpmatrix\n\nThe phase gate is the square of the T gate: S = T^2.\n\n\n\n\n\n","category":"constant"},{"location":"api/operators.html#Schrodinger.Gate.T","page":"Operator Library","title":"Schrodinger.Gate.T","text":"Gate.T\n\nThe T gate:\n\nT =\nbeginpmatrix\n1  0 \n0  exp(iπ4)\nendpmatrix\n\nThe phase gate is the square of the T gate: S = T^2.\n\n\n\n\n\n","category":"constant"},{"location":"examples/DRAG.html#DRAG","page":"DRAG","title":"DRAG","text":"","category":"section"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"This example shows how to implement a NOT gate on a qubit using a Gaussian pulse. We then extend this method to a three-level slightly anharmonic energy spectrum with nearest level coupling. As we will see, the gate error increases due to leakage into the third level. To remedy this, we implement Derivative Removal by Adiabatic Gate (DRAG) which offers better gate fidelity than an ordinary Gaussian pulse (see the References).","category":"page"},{"location":"examples/DRAG.html#A-simple-NOT-Gate","page":"DRAG","title":"A simple NOT Gate","text":"","category":"section"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"First, we will apply a simple NOT gate to a qubit in the ground state. The Hamiltonian for our qubit in the lab frame can be written as ħ(ω11+ℇ(t)σ_x) where ħω is the transition energy, σ_x is the Pauli-X operator, and ℇ(t)=ℇ^x(t)cos(ω_dt) represents our control of the system using a drive frequency ω_d. Any control ℇ^x(t) such that the integral of ℇ^x over the total gate time equals π will result in a complete inversion. It is common to use a Gaussian shaped π-pulse to implement a NOT gate. For our purposes, we will find it more convenient to work in the rotating frame with respect to our drive frequency ω_d. When this frequency is resonant with the qubit frequency ω, the Hamiltonian is given by ħℇ^x(t)σ_x2. If we are going to solve the time dynamics for this system, we also have to define our pulse in the rotating frame.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"using Schrodinger, SpecialFunctions, SparseArrays\n\nfunction rotgaussianpulse(t::Real,p::Vector)\n    # normalized pulse centered on t=0, begins and ends at 0\n    tg  = p[1] # gate time\n    σ   = p[2] # standard deviation\n    A   = p[3] # amplitude\n    B   = inv(√(2π)*σ*erf(tg/(√(8)*σ))-tg*gaussian(0.5tg,σ)) # normalize\n    Ɛˣ = A*B*(gaussian(t,σ)-gaussian(0.5tg,σ))\n    return Ɛˣ\nend\n\nH = σx/2 # same as create(2)/2 + destroy(2)/2; using natural units where ħ=1","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"We are now ready to solve for the time dynamics and plot our results. We'll use parameters that are typical for Transmon qubits.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"tg = 6e-9 # gate time 6ns\nσ = 0.5tg # standard deviation of gaussian pulse\ng = basis(2,0) # begin in ground state\ntspan = (-tg/2,tg/2) # pulse centered at t=0\n\nres1 = sesolve((qzero(2),(H,rotgaussianpulse,[tg,σ,π])),g,tspan,saveat=tg/200)\n\nusing PyPlot\nfigure(); # hide\nplot(res1.times*1e9,levelprobs(res1.states)); grid();\nxlabel(\"Time (ns)\"); ylabel(\"Level Probabilities\");\nlegend([\"Ground State\", \"Excited State\"]);\ntight_layout(); savefig(joinpath(\"img\",\"qubitNOT.svg\")); # hide","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"(Image: qubit NOT gate)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"As is expected, the system moves from the ground state to the excited state.","category":"page"},{"location":"examples/DRAG.html#Three-level-system","page":"DRAG","title":"Three-level system","text":"","category":"section"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"In reality, one must worry about leakage into other states of the system, especially when dealing with short gate times. Let's see how our Gaussian pulse performs on a three-level anharmonic system. We will again work in the rotating frame at resonance with the qubit frequency. This system will have an anharmonicity Δ, which is the detuning of the 2nd excited state with respect to the drive frequency, and an additional parameter λ describing the relative strength of the 1-2 transition compared to the 0-1 transition (see [1] for more details). Let's create the Hamiltonian and perform the same time evolution.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"Δ = 2π*(-400e6) # anharmonicity\nλ = √2 # relative transition strength\nΠ₂ = basis(3,2) * basis(3,2)' # projector for the 2nd level\nHc = Δ*Π₂ # constant Hamiltonian\nHd = create(3)/2 + destroy(3)/2 # affected by Ɛˣ\ng = basis(3,0)\n\nres2 = sesolve((Hc,(Hd,rotgaussianpulse,[tg,σ,π])),g,tspan,saveat=tg/200)\nfigure(); # hide\nplot(res2.times*1e9,levelprobs(res2.states)); grid()\nxlabel(\"Time (ns)\"); ylabel(\"Level Probabilities\");\nlegend([\"Ground State\", \"1st Excited State\", \"2nd Excited State\"]);\ntight_layout(); savefig(joinpath(\"img\",\"3levelNOT.svg\")); # hide","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"(Image: 3-level NOT gate)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"Instead of working perfectly, our system leaks into the 2nd energy level (we'll quantify this later). This becomes problematic when we're trying perform useful computations. DRAG is one possible remedy where introducing drive detuning and a second quadrature control, that is ℇ(t)=ℇ^x(t)cos(ω_dt)+ℇ^y(t)sin(ω_dt), helps eliminate some of the leakage. Let's see how much of an improvement we get. We'll need to define a few more functions for the new controls.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"function DRAGx(t::Real,p::Vector)\n    # Ɛˣ for fifth order DRAG\n    tg  = p[1] # gate time\n    σ   = p[2] # standard deviation\n    A   = p[3] # amplitude\n    Δ   = p[4] # anharmonicity\n    λ   = p[5] # relative strength of transitions\n    Ɛˣ = rotgaussianpulse(t,[tg,σ,A]) + (λ^2-4)*rotgaussianpulse(t,[tg,σ,A])^3/(8*Δ^2) - (13λ^4-76λ^2+112)*rotgaussianpulse(t,[tg,σ,A])^5/(128Δ^4)\n    return Ɛˣ\nend\n\nfunction DRAGy(t::Real,p::Vector)\n    # Ɛʸ for fifth order DRAG\n    tg  = p[1] # gate time\n    σ   = p[2] # standard deviation\n    A   = p[3] # amplitude\n    Δ   = p[4] # anharmonicity\n    λ   = p[5] # relative strength of transitions\n    B   = inv(√(2π)*σ*erf(tg/(√(8)*σ))-tg*gaussian(0.5tg,σ))\n    Ɛˣ′ = A*B*Schrodinger.gaussianprime(t,σ)\n    Ɛʸ = -Ɛˣ′/Δ + 33*(λ^2-2)*rotgaussianpulse(t,[tg,σ,A])^2*Ɛˣ′/(24*Δ^3)\n    return Ɛʸ\nend\n\nfunction dydet(t::Real,p::Vector)\n    # dynamical detuning for fifth order DRAG\n    tg  = p[1] # gate time\n    σ   = p[2] # standard deviation\n    A   = p[3] # amplitude\n    Δ   = p[4] # anharmonicity\n    λ   = p[5] # relative strength of transitions\n    δ₁ = (λ^2-4)*rotgaussianpulse(t,[tg,σ,A])^2/(4*Δ) - (λ^4-7λ^2+12)*rotgaussianpulse(t,[tg,σ,A])^4/(16Δ^3)\n    return δ₁\nend\n\nΠ₁ = basis(3,1) * basis(3,1)' # projector for 1st level\nHdet = Π₁ # affected by dynamical detuning\nHdx = create(3)/2 + destroy(3)/2 # affected by Ɛˣ\nHdy = im*create(3)/2 - im*destroy(3)/2 # affected by Ɛʸ\n\nres3 = sesolve((Hc,(Hdet,dydet,[tg,σ,π,Δ,λ]),(Hdx,DRAGx,[tg,σ,π,Δ,λ]),(Hdy,DRAGy,[tg,σ,π,Δ,λ])),g,tspan,saveat=tg/200)\nfigure(); # hide\nplot(res3.times*1e9,levelprobs(res3.states)); grid()\nxlabel(\"Time (ns)\"); ylabel(\"Level Probabilities\");\nlegend([\"Ground State\", \"1st Excited State\", \"2nd Excited State\"]);\ntight_layout(); savefig(joinpath(\"img\",\"3levelDRAG.svg\")); # hide","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"(Image: 3-level DRAG)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"There is a noticeable improvement over the simple Gaussian pulse, but how much better is the new gate?","category":"page"},{"location":"examples/DRAG.html#Fidelity","page":"DRAG","title":"Fidelity","text":"","category":"section"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"We can calculate the fidelity of our gates by comparing their output to the ideal case. Our gates behave ideally when λ=0 and there is no leakage into the 2nd excited state. Using the same measure of error as in [1], we can take the overall gate fidelity to be the average of gate fidelities when using the 6 axial states on the Bloch sphere as inputs.","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"tgs = (2:0.5:10)*1E-9 # gate times\nFg_res = Matrix{Float64}(undef,length(tgs),2) # initialize matrix for number of solves\naxialkets  = [normalize!(Ket([1,1,0])),   # +X\n              normalize!(Ket([1,-1,0])),  # -X\n              normalize!(Ket([1,im,0])),  # +Y\n              normalize!(Ket([1,-im,0])), # -Y\n              normalize!(Ket([1,0,0])),   # +Z\n              normalize!(Ket([0,1,0]))]   # -Z\naxialops = Operator.(axialkets) # need density operators too\n\nUideal = qeye(3); Uideal[1:2,1:2] = data(σx)\nfor (i,tg) in enumerate(tgs)\n    sum1 = 0 # sum of Gaussian gate fidelities\n    sum2 = 0 # sum of DRAG gate fidelities\n    for j = 1:6\n        ket = axialkets[j]\n        op = axialops[j]\n        tspan = (-tg/2,tg/2)\n        # Gaussian\n        res4_1 = sesolve((Hc,(Hd,rotgaussianpulse,[tg,σ,π])),ket,tspan)\n        sum1 += trace(Uideal*op*Uideal'*(res4_1.states[end]*res4_1.states[end]'))\n        # DRAG\n        res4_2 = sesolve((Hc,(Hdet,dydet,[tg,σ,π,Δ,λ]),(Hdx,DRAGx,[tg,σ,π,Δ,λ]),(Hdy,DRAGy,[tg,σ,π,Δ,λ])),ket,tspan)\n        sum2 += trace(Uideal*op*Uideal'*(res4_2.states[end]*res4_2.states[end]'))\n    end\n    Fg_res[i,:] = [sum1/6 sum2/6] # take average\nend\n\nfigure(); # hide\nplot(tgs*1E9, 1 .- Fg_res); ylim([10E-8,1]); grid()\ntitle(\"Average gate fidelity averaging over all input states\");\nyscale(\"log\"); xlabel(\"Gate Time (ns)\"); ylabel(\"Gate Error 1-Fg\");\nlegend([\"Gaussian\",\"DRAG 5th Order\"]);\ntight_layout(); savefig(joinpath(\"img\",\"fidelities.svg\")); # hide","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"(Image: NOT-gate fidelities)","category":"page"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"For a gate time of 6ns, taking advantage of DRAG results in a gate error that is 2 orders of magnitude less than when using Gaussian pulses.","category":"page"},{"location":"examples/DRAG.html#References","page":"DRAG","title":"References","text":"","category":"section"},{"location":"examples/DRAG.html","page":"DRAG","title":"DRAG","text":"Motzoi, F., Gambetta, J. M., Rebentrost, P., & Wilhelm, F. K. (2009). Simple Pulses for Elimination of Leakage in Weakly Nonlinear Qubits. Physical Review Letters, 103(11), 110501. 10.1103/PhysRevLett.103.110501 or arXiv:0901.0534","category":"page"},{"location":"man/quantumobjects.html#Quantum-Objects","page":"Quantum Objects","title":"Quantum Objects","text":"","category":"section"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"This section is an introduction to the basic objects used in Schrodinger.jl. It contains an overview of the quantum object generation capabilities offered, and basic mathematical operations. There are 3 types of basic quantum objects: Ket, Bra, and Operator. All of these objects can be created from a Julia vector or matrix, as appropriate, with a generating function, or by composition of previously made objects.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Since these objects are very similar to regular vectors and matrices, simple mathematics and functions behave as would be expected.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Functions for creating states and operators are listed in the API sections State Library and Operator Library","category":"page"},{"location":"man/quantumobjects.html#creating_states","page":"Quantum Objects","title":"Creating States","text":"","category":"section"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"There are three ways of representing quantum states: with Ket or Bra vectors for pure states, and with density Operators for both pure and mixed states. Note that a density operator is just a normalized, Hermitian Operator.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"We already saw that it is possible to create a pure ket state from a Julia vector using the Ket function. Kets (and bras) are by default stored as sparse vectors. Schrodinger.jl exposes a few functions to generate common states. These functions are listed in the table below; click on the function name for more details.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Function Type Notes\nbasis sparse Ket A simple basis vector. The function fock is an alias to this one.\ncoherent dense Ket A quantum harmonic oscillator coherent state.\nmaxmixed sparse Operator The maximally mixed state.\nthermal sparse Operator A thermal state.","category":"page"},{"location":"man/quantumobjects.html#Kets","page":"Quantum Objects","title":"Kets","text":"","category":"section"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"A simple computational state like 3 can be created with the basis function. basis takes two arguments: the dimension of the Hilbert space, and the level. Remember that the ground state is given by the zeroth level.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Let us create a Ket for a three-level atom in the first excited e1 state, which is level \"1\".","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"julia> e1 = basis(3,1)\n3-d Ket{SparseVector{Float64, Int64}, 1} with dimensions 3\n1.00∠0°|1⟩","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"A quantum harmonic oscillator can be in what is called a coherent state. Schrodinger.jl provides a function to create such a state. A coherent state is parameterized by α, which is a complex number determining the amplitude and phase of the state. Remember that a quantum harmonic oscillator is infinite-dimensional. The state space must therefore be truncated to a finite number of level. The coherent function takes two arguments, the truncated space size N, and α.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"julia> α = 1.5+1im;\n\njulia> Φ = coherent(10,α)\n10-d Ket{Vector{ComplexF64}, 1} with dimensions 10\n0.47∠101°|3⟩ + 0.45∠67°|2⟩ + 0.42∠135°|4⟩ + 0.35∠34°|1⟩ + 0.34∠168°|5⟩ +…","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"A coherent state is a superposition of number states, which is evident when displayed in the number basis. Note the three dots at the end of the line: Schrodinger.jl only displays the 5 largest components of a Ket vector. You can extract the underlying storage array with the data function:","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"julia> Array(Φ)\n10-element Vector{ComplexF64}:\n     0.196911585370312 - 1.1502482981244248e-15im\n   0.29536827731526705 + 0.19691218487684775im\n   0.17404455782964093 + 0.4177069387911491im\n  -0.09044382705530865 + 0.4622684493937808im\n   -0.2988457199097717 + 0.30135702848043705im\n  -0.33585925021170143 + 0.06863455364460008im\n  -0.23186949330792594 - 0.0943429682845047im\n  -0.09879088215342524 - 0.14553280324422505im\n -0.000832521254162528 - 0.09948454819622156im\n  0.047205161874623196 - 0.07210790803314954im","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"A mixed state is a probabilistic mixture of pure states, and it is important to understand the difference between the two. For example, we can create a superposition between two state of a three-level atom by adding kets together:","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"julia> ψ = e1 + basis(3,0)\n3-d Ket{SparseVector{Float64, Int64}, 1} with dimensions 3\n1.00∠0°|0⟩ + 1.00∠0°|1⟩","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"note: Note\nNotice that the coefficients of the new state ψ add up to 2. By default, Schrodinger.jl does not renormalize states. This is because adding, for example, three states together would incur two renormalization steps (one per addition) and the resulting state would most likely not be what was desired. Instead, you must add up the states you want in the desired proportions, and then use the normalize! function.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Let's make sure that this state is normalized:","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"julia> normalize!(ψ)\n3-d Ket{SparseVector{Float64, Int64}, 1} with dimensions 3\n0.71∠0°|0⟩ + 0.71∠0°|1⟩","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"This pure state now represents a physical quantum superposition.","category":"page"},{"location":"man/quantumobjects.html#Density-Matrices","page":"Quantum Objects","title":"Density Matrices","text":"","category":"section"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Let's now imagine that we have a device that creates three-level atoms, but every time you ask for an one, the machine creates an atom in the state ψ with probability 1/3, and in the state e1 with probability 2/3. After pressing the \"new atom\" button and obtaining a fresh atom, but before looking at it, the state of that atom is unknown. This situation describes a mixed state, and such a state can only be represented by a density matrix (or density operator).","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"In bra-ket notation, the a pure state can be transformed in a density matrix by multiplying it on the right with its dual bra: ψψ. This is done with the complex transpose operation in Schrodinger.jl. This is therefore how we create the correct state for our mystery atom:","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"julia> ρ = 1/3 * ψ*ψ' + 2/3 * e1*e1'\n3×3 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 3\n 0.166667  0.166667   ⋅\n 0.166667  0.833333   ⋅\n  ⋅         ⋅         ⋅","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Notice that because the probabilities 1/2 and 2/3 add up to 1, the matrix is already properly normalized: its trace is one. If that had not been the case, we could have normalized the density operator with the normalize! function again. The density operator of the atom is Hermitian, as it should be. Schrodinger.jl uses the same type (Operator) to represent both density matrices and \"regular\" linear operators.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Density matrices can be created directly from a matrix or from a ket with the Operator function:","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"julia> ρ += Operator(basis(3,2))\n3×3 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 3\n 0.166667  0.166667   ⋅\n 0.166667  0.833333   ⋅\n  ⋅         ⋅        1.0\n\njulia> normalize!(ρ)\n3×3 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 3\n 0.0833333  0.0833333   ⋅\n 0.0833333  0.416667    ⋅\n  ⋅          ⋅         0.5","category":"page"},{"location":"man/quantumobjects.html#Creating-Operators","page":"Quantum Objects","title":"Creating Operators","text":"","category":"section"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Linear operators are used to act on quantum states, either continuously, through time evolution under a Hamiltonian, or discretely. As mentioned previously, kets are element of a Hilbert space. Operators are not elements of that space, they act on elements to take them to other elements.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Operators can be created from a Julia matrix with the Operator function and are by default stored as sparse matrices. As with states, Schrodinger.jl contains functions to create common operators:","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Function Type Notes\nqzero sparse Operator The zero operator.\nqeye sparse Operator The identity operator.\nnumberop sparse Operator The particle number operator.\ndestroy sparse Operator The quantum harmonic oscillator lowering operator.\ncreate sparse Operator The quantum harmonic oscillator raising operator.\ndisplacementop dense Operator The quantum harmonic oscillator displacement operator.\nsqueezeop dense Operator The quantum harmonic oscillator squeeze operator.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Schordinger.jl also exposes the 3 Pauli matrices, the identity operator, and the raising and lowering operators for two-level systems (qubits) as built-in constants. Those are σx, σy, σz, σ0, σ₊, and σ₋. Note that unlike QuTiP, the qubit raising operator will raise 0 to 1.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"New operators can be constructed from existing ones by adding them or multiplying them together or with numbers. Operators can be non-Hermitian, unlike density matrices.","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"julia> a = destroy(5)\n5×5 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 5\n  ⋅   1.0   ⋅        ⋅        ⋅\n  ⋅    ⋅   1.41421   ⋅        ⋅\n  ⋅    ⋅    ⋅       1.73205   ⋅\n  ⋅    ⋅    ⋅        ⋅       2.0\n  ⋅    ⋅    ⋅        ⋅        ⋅\n\njulia> a'*a + 1/2\n5×5 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 5\n 0.5   ⋅    ⋅    ⋅    ⋅\n  ⋅   1.5   ⋅    ⋅    ⋅\n  ⋅    ⋅   2.5   ⋅    ⋅\n  ⋅    ⋅    ⋅   3.5   ⋅\n  ⋅    ⋅    ⋅    ⋅   4.5\n\njulia> a' + a\n5×5 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 5\n  ⋅   1.0       ⋅        ⋅        ⋅\n 1.0   ⋅       1.41421   ⋅        ⋅\n  ⋅   1.41421   ⋅       1.73205   ⋅\n  ⋅    ⋅       1.73205   ⋅       2.0\n  ⋅    ⋅        ⋅       2.0       ⋅","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"note: Note\nAdding and substracting numbers to and from operators adds (substracts) the identity matrix multiplied by that number.","category":"page"},{"location":"man/quantumobjects.html#Basic-Mathematical-Operations","page":"Quantum Objects","title":"Basic Mathematical Operations","text":"","category":"section"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Basic mathematics with kets, density matrices and operators in Schrodinger.jl is very similar to regular linear algebra with vectors and matrices. This is to be expected, kets are elements of a Hilbert space, which is a vector space, and operators are transformations that take kets to kets. The only difference is that when performing operations between quantum objects, their subspace dimensions must be identical. This condition is explained in more details in the next section.","category":"page"},{"location":"man/quantumobjects.html#Algebra","page":"Quantum Objects","title":"Algebra","text":"","category":"section"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"All basic algebra functions work as expected:","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"julia> basis(2,0) + basis(2,1)\n2-d Ket{SparseVector{Float64, Int64}, 1} with dimensions 2\n1.00∠0°|0⟩ + 1.00∠0°|1⟩\n\njulia> basis(3,0) + 1\n3-d Ket{SparseVector{Float64, Int64}, 1} with dimensions 3\n2.00∠0°|0⟩ + 1.00∠0°|1⟩ + 1.00∠0°|2⟩\n\njulia> 2.5im*basis(2,0)\n2-d Ket{SparseVector{ComplexF64, Int64}, 1} with dimensions 2\n2.50∠90°|0⟩\n\njulia> thermal(4,0.3)/2 + Operator(coherent(4,1))/2\n4×4 Operator{Matrix{Float64}, 1} with dimensions 4\n 0.569363   0.184874   0.124977   0.0911074\n 0.184874   0.275112   0.125807   0.0917127\n 0.124977   0.125807   0.105588   0.0619989\n 0.0911074  0.0917127  0.0619989  0.049937\n\njulia> numberop(4) + 1/2\n4×4 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 4\n 0.5   ⋅    ⋅    ⋅\n  ⋅   1.5   ⋅    ⋅\n  ⋅    ⋅   2.5   ⋅\n  ⋅    ⋅    ⋅   3.5\n\njulia> create(4)^2\n4×4 Operator{SparseMatrixCSC{Float64, Int64}, 1} with dimensions 4\n  ⋅        ⋅        ⋅    ⋅\n  ⋅        ⋅        ⋅    ⋅\n 1.41421   ⋅        ⋅    ⋅\n  ⋅       2.44949   ⋅    ⋅","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"note: Note\nAs explained previously, adding and substracting numbers to and from operators adds (substracts) the identity matrix multiplied by that number. Adding and substracting quantum objects might also lead to non-normalized states. See the Norms section for more details.","category":"page"},{"location":"man/quantumobjects.html#Functions","page":"Quantum Objects","title":"Functions","text":"","category":"section"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"Many other mathematical functions are available and work as expected:","category":"page"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"exp, sqrt, log\ntrig functions are missing for now!\nreal, imag, abs, abs2\nadjoint, conj, transpose","category":"page"},{"location":"man/quantumobjects.html#Other-Quantum-Objects","page":"Quantum Objects","title":"Other Quantum Objects","text":"","category":"section"},{"location":"man/quantumobjects.html","page":"Quantum Objects","title":"Quantum Objects","text":"There exist other quantum objects, like Liouvillians and Propagators, but those will be discussed in later sections.","category":"page"},{"location":"index.html#Schrodinger.jl-Documentation","page":"Home","title":"Schrodinger.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Schrodinger.jl is a package for quantum simulations. Currently it is focused on time dynamics, but will hopefully be expanded to perform all kind of operations.","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This website serves as documentation for the Schrodinger.jl package. If you are just getting started with Schrodinger.jl, it is recommended that you first read the manual (or at least the Getting Started page). The different sections of the manual are easily accessible on the left sidebar.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A few tutorials will soon be available.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you are looking for a particular function, you may browse the API by topic or use the search functionality.","category":"page"},{"location":"index.html#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Contributions are highly welcomed! Please see the repository on Github and feel free to open issues if you find a bug or if you feel a feature is missing.","category":"page"},{"location":"index.html#Author","page":"Home","title":"Author","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package was written by Jérémy Béjanin. If you find it useful, drop me a line!","category":"page"}]
}
